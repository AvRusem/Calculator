Разработайте на C++ консольную программу «Калькулятор», позволяющую объявлять переменные и функции и выполнять арифметические операции над ними.

# Требования к коду
Решение должно использовать объектно-ориентированный подход, содержать подходящие классы и структуры, моделирующие сущности предметной области. Примените подходящие для решения задачи контейнеры STL. 
Наличие автотестов для программы в целом или для её классов и функций приветствуется. Вы можете использовать привычный вам фреймворк для написания тестов, либо использовать стандартный макрос assert. 
Используйте привычный вам стиль именования классов, переменных, методов и функций.

# Формат входных и выходных данных
Входные данные поступают из stdin построчно. Выходные данные выводятся в stdout. Каждая входная строка содержит одну из показанных ниже команд. Каждая команда выполняется сразу после считывания. 
Работа программы заканчивается при считывании конца файла из stdin.

Список команд:
* **var <идентификатор>**

Объявляет переменную типа double с именем <идентификатор>. Идентификатор не должен совпадать ни с одним из ранее объявленных имен переменных и функций. Значение переменной после ее объявления не 
определено (можно использовать значение NAN (not a number) для этих целей). В отсутствие ошибок в stdout ничего не выводится. При наличии ошибки команда игнорируется, а в stdout выводится сообщение об ошибке.

* **let <идентификатор1>=<число с плавающей запятой>** либо **let <идентификатор1>=<идентификатор2>**

Присваивает переменной с именем <идентификатор1> числовое значение, либо текущее значение ранее объявленного идентификатора с именем <идентификатор2>. Если переменная с именем <идентификатор1> не была ранее 
объявлена, происходит объявление новой переменной. В качестве <идентификатора1> не может выступать имя функции. В отсутствие ошибок в stdout ничего не выводится. В случае ошибки команда игнорируется, а в 
stdout выводится сообщение об ошибке.

* **fn <идентификатор1>=<идентификатор2>** либо **fn <идентификатор1>=<идентификатор2><операция><идентификатор3>**

fn <идентификатор1>=<идентификатор2><операция><идентификатор3> Объявляет новую функцию с ранее необъявленным именем <идентификатор1>, значением которой будет либо значение идентификатора <идентификатор2>, 
либо результат применения одной из следующих бинарных операций к значениям ранее объявленных идентификаторов <идентификатор2> и <идентификатор3> в момент вычисления значения функции:
- **\+** Сложение. Результат – сумма значений <идентификатор2> и <идентификатор3>.
- **\-** Вычитание. Результат – разность значений <идентификатор2> и <идентификатор3>.
- **\*** Умножение. Результат – произведение значений <идентификатор2> и <идентификатор3>.
- **/** Деление. Результат – частное значений <идентификатор2> и <идентификатор3>.
- Если значение хотя бы одного из операндов операции не определено, результатом операции должно быть неопределенное значение (NAN). В отсутствие ошибок в stdout ничего не выводится. В случае ошибки команда 
игнорируется, а в stdout выводится сообщение об ошибке.

* **print <идентификатор>**

Выводит в stdout значение ранее объявленного идентификатора. Если идентификатором являлась переменная, то выводится ее значение, а если функция, то выводится вычисленное значение функции. 
Значение идентификатора выводится с точностью в 2 знака после запятой. Например, число 0.33333 должно быть выведено как 0.33. Если значение идентификатора не определено, должно быть выведено nan. 
В случае ошибки (например, попытка вывести значение необъявленного идентификатора), команда игнорируется, а в stdout должен быть выведено сообщение об ошибке.

* **printvars**

Выводит в stdout имена и значения всех ранее объявленных переменных, отсортированных по алфавиту, по одному в каждой строке в следующем формате: <идентификатор>:<значение> Значение переменной выводится 
с точностью 2 знака после запятой. Если значение переменной не определено, должно быть выведено nan. Если ни одной переменной не было объявлено к моменту выполнения команды printvars, в stdout выводиться 
ничего не должно.

* **printfns**

Выводит в stdout имена и значения всех ранее объявленных функций, отсортированных по алфавиту, по одному в каждой строке в следующем формате: <идентификатор>:<значение> Значение функции выводится с точностью в 
2 знака после запятой. Если значение функции не определено, должно быть выведено nan. Если ни одной функции не было объявлено к моменту выполнения команды printfns, в stdout выводиться ничего не должно.

**Идентификатор** – непустая строка, в которой можно использовать буквы английского алфавита, цифры и символ подчеркивания. Идентификатор не может начинаться с цифры. Идентификаторы используются в качестве имен переменных и функций.

# Примеры
## Объявление, присваивание и вывод значений переменных

| stdin | stdout | Пояснение |
| --------- | --------- | --------- |
|   var x  |     |  Объявляем переменную x   |
|   print x  |   nan  |   Значение переменной x пока не определено  |
|   let x = 42  |     |   Присваиваем переменной x значение 42  |
|   print x  |   42.00  |   Теперь x хранит значение 42  |
|   let x = 1.234  |     |   Значение переменной можно изменить  |
|   print x  |   1.23  |   Значение выводится с точностью 2 знака после запятой  |
|   let y=x  |     |  Автоматически объявляем переменную y и присваиваем ей текущее значение x  |
|   let x=99  |     |   Присваиваем переменной x значение 99  |
|   printvars  |  x:99.00 y:1.23   |  Переменная y хранит присвоенное ей значение x. Последующие манипуляции над x не оказывают на нее влияния. Переменные выводятся в алфавитном порядке  |

## Объявление функций

| stdin | stdout | Пояснение |
| ------- | -------- | ----------- |
| var x |        | Объявляем переменную x |
| var y |        | Объявляем переменную y |
| fn XPlusY = x + y |  | Объявляем функцию XPlusY, которая складывает значения x и y |
| print XPlusY | nan | Значение функции не определено, так как не определены значения ее аргументов x и y |
| let x = 3 |     | Присваиваем переменной x значение 3 |
| let y = 4 |     | Присваиваем переменной y значение 4 |
| print XPlusY | 7.00 | Теперь значение функции XPlusY определено и равно 7.00 |
| let x = 10 |    | Изменяем значение переменной x на 10 |
| print XPlusY | 14.00 | Значение функции XPlusY зависит от значений ее аргументов x и y и равно 14.00 |
| let z = 3.5 |   | Объявляем переменную z со значением 3.5 |
| fn XPlusYDivZ = XPlusY / z | | Объявляем функцию XPlusYDivZ, которая делит значение функции XPlusY на значение переменной z |
| printfns | XPlusY:14.00 XPlusYDivZ:4.00 | Значения функций XPlusY и XPlusYDivZ выводятся в алфавитном порядке: XPlusY:14.00, XPlusYDivZ:4.00 |

## Различия между fn и let

| stdin           | stdout | Пояснение                                                        |
|-----------------|--------|------------------------------------------------------------------|
| let v=42        |        | Объявляем переменную v и присваиваем ей значение 42                |
| let variable=v  |        | Переменная variable хранит значение v (42)                         |
| fn function=v   |        | Функция function хранит действие, которое будет вычислено при получении значения функции |
| let v=43        |        | Изменяем значение переменной v на 43                               |
| print variable  | 42.00  | Переменная variable хранит ранее присвоенное значение 42           |
| print function  | 43.00  | Значением функции function будет значение переменной v (43), вычисленное в момент вызова функции (а не ее объявления) |

## Пример: вычисление площади круга

| stdin                | stdout   | Пояснение                                                                              |
|----------------------|----------|----------------------------------------------------------------------------------------|
| var radius           |          | Объявляем переменную radius                                                            |
| let pi=3.14159265    |          | Присваиваем переменной pi значение 3.14159265                                          |
| fn radiusSquared=radius\*radius |   | Объявляем функцию radiusSquared, которая вычисляет квадрат радиуса                      |
| fn circleArea=pi\*radiusSquared |    | Объявляем функцию circleArea, которая вычисляет площадь круга                          |
| let radius=10        |          | Присваиваем переменной radius значение 10                                               |
| print circleArea     | 314.16   | Выводим значение функции circleArea при радиусе, равном 10                              |
| let circle10Area=circleArea |     | Присваиваем переменной circle10Area значение функции circleArea при радиусе, равном 10   |
| let radius=20        |          | Изменяем значение переменной radius на 20                                               |
| let circle20Area=circleArea |     | Присваиваем переменной circle20Area значение функции circleArea при радиусе, равном 20   |
| printfns | circleArea:1256.64 radiusSquared:400.00 | | Выводим значения функций circleArea и radiusSquared                                    |
| printvars | circle10Area:314.16 circle20Area:1256.64<br>pi:3.14<br>radius:20.00 | | Выводим значения переменных circle10Area, circle20Area, pi и radius                     |

## Пример: вычисление последовательности Фибоначчи

| stdin              | stdout | Пояснение                                                             |
| ------------------ | ------ | --------------------------------------------------------------------- |
| let v0=0           |        | Объявляем переменную `v0` и присваиваем ей значение `0`               |
| let v1=1           |        | Объявляем переменную `v1` и присваиваем ей значение `1`               |
| fn fib0=v0         |        | Объявляем функцию `fib0` равной значению `v0`                          |
| fn fib1=v1         |        | Объявляем функцию `fib1` равной значению `v1`                          |
| fn fib2=fib1+fib0  |        | Объявляем функцию `fib2` равной сумме `fib1` и `fib0`                  |
| fn fib3=fib2+fib1  |        | Объявляем функцию `fib3` равной сумме `fib2` и `fib1`                  |
| fn fib4=fib3+fib2  |        | Объявляем функцию `fib4` равной сумме `fib3` и `fib2`                  |
| fn fib5=fib4+fib3  |        | Объявляем функцию `fib5` равной сумме `fib4` и `fib3`                  |
| fn fib6=fib5+fib4  |        | Объявляем функцию `fib6` равной сумме `fib5` и `fib4`                  |
| printfns | fib0:0.00<br>fib1:1.00<br>fib2:1.00<br>fib3:2.00 <br>fib4:3.00 <br>fib5:5.00 <br>fib6:8.00 | | Выводим значения функций `fib0`, `fib1`, `fib2`, `fib3`, `fib4`, `fib5` и `fib6` |
| let v0=1           |        | Изменяем значение переменной `v0` на `1`                               |
| let v1=1           |        | Изменяем значение переменной `v1` на `1`                               |
| printfns | fib0:1.00 <br>fib1:1.00 <br>fib2:2.00 <br>fib3:3.00 <br>fib4:5.00 <br>fib5:8.00 <br>fib6:13.00 | | Выводим обновленные значения функций `fib0`, `fib1`, `fib2`, `fib3`, `fib4`, `fib5` и `fib6` |

## Дополнительное задание (опционально)

Наивный подход к вычислению значений функций в некоторых ситуациях может приводить длительной работе программы. Например, вычисление значения хотя бы 50-го числа последовательности Фибоначчи с использованием 
функций fib0, fib1, fib2, …, fib50 может занимать несколько секунд, или даже минут. Если ваше решение страдает от этой проблемы, усовершенствуйте программу, устранив причину долгой работы.
